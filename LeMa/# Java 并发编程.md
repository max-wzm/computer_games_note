# Java 并发编程

## Java 锁

### Lock 接口与队列同步器

尽管 `synchronized` 作为一种隐式锁已经提供了相当多好用的并发特性，但是仍然在以下方面不够灵活：

- 非阻塞地获取锁：tryLock
- 响应中断：线程被中断时，抛出异常，并且释放锁
- 超时获取：在一定时间内争抢锁

因此，Java 提供了 Lock 接口，能够让使用者来使用锁。

Lock 接口的 api 除了提供普通的锁方法，还提供了上述 synchronized 无法实现的一些锁方法。

实现 Lock 接口的过程可能非常复杂，此时就需要队列同步器。

队列同步器封装了锁实现的一些细节。队列同步器基于模板方法，实现者重写其中的一些方法，即可使用队列同步器提供的模板方法。实现者可以通过队列同步器提供的模板方法来实现 Lock 接口。

简言之，Lock 接口是面向user的，而队列同步器是面向developer的。

接下来重点介绍队列同步器的内部实现。

#### 操作系统依赖

队列同步器的实现依赖于操作系统（或者说JVM）提供的一些底层方法，主要包括两类：

1. 原子指令 CAS （实际是CPU提供的指令）：
   compareAndSet(int expect, int update)：检验一个变量，如果它的值是expect，就修改为update。
   getVar - compareAndSet 的过程当中，如果中间有另一线程并发修改，那么compareAndSet 会失败。
   循环执行上述步骤，直到 cas 成功，此时线程获得锁。
   这样的过程称作 **自旋**。如果你做过 xv6 的lab，可以发现 xv6 的 spinlock就是基于这样的原理实现的，（xv6 使用的原子指令是testAndSet）。
2. 线程调度：等待、唤醒

为什么 Java 不直接用操作系统实现的锁呢？

挖个坑，有空会写 Linux 当中的锁实现。

1. 操作系统的锁（mutex、rwlock）也是基于CAS和调度实现的
2. 操作系统实现的锁功能有限，不如自己定制
3. Java 运行在JVM当中，不直接与操作系统接触

#### 同步队列

同步队列是同步器当中的一个双向队列，存储的是所有尝试获取同步状态（或者说此锁）的节点。一个节点对应了一个线程。

如果一个线程获得锁失败了，那么会加入到队列的尾部。为了维护队列尾部的线程安全，加入尾部的操作也是通过cas实现的。

队列当中的节点会进行自旋，探测是否能获得锁。不过他们是处于阻塞状态的，换句话说：我想自旋但是我现在睡着了。

队首是获得了锁的节点，其他的节点则处于阻塞当中。一旦首结点释放锁，他会通知他的后继等待的结点，将其唤醒。后继醒来之后就在自旋，尝试获取锁。

只有在前驱为首结点，且已经释放锁的前提下，后继才可以获得锁。获得锁之后，后继会变成首结点。setHead的过程不需要cas，因为只有一个结点能setHead，不存在并发安全的问题。

#### 互斥锁的获取与释放

同步器通过 acquire 方法获取同步状态。此方法是独占的，并且对中断不第三，也就是说，acquire失败的线程，不会因为中断而放弃争抢锁（移出同步队列）。

acquire 做了以下的事情：

1. 调用 tryAcquire（重写方法）尝试获取锁
2. 如果获取失败了，则构造同步节点 (Node.EXCLUSIVE), 以cas的方式加入到队尾当中，处于等待状态。
3. 节点如果被首节点唤醒，或者被中断，就退出等待状态，进入自旋，尝试获得锁，失败则再次等待。只有头结点的后继能获得锁！

首结点完成任务后，会进行锁的释放：

1. 调用 tryRelease 释放 
2. 通过LockSupport，调用unparkSuccessors，唤醒后继结点。

#### 共享锁的获取与释放

共享锁的特点在于读读共享、读写互斥、写写互斥。

同步器暴露的方法是 acquireShared:

1. 调用 tryAcquireShared (重写方法) 尝试获取锁
2. 如果失败，则构造同步节点（Node.SHARED）加入队列当中
3. 节点如果被首节点唤醒，或者被中断，就退出等待状态，进入自旋，尝试获得锁，失败则再次等待。只有头结点的后继能获得锁！

释放的过程也是类似的，和互斥锁的主要区别在于 tryReleaseShared （重写方法）需要确保多线程共享时的资源能安全释放。

#### 互斥超时锁的获取与释放

acquireNanos 是基于 acquireInterruptibly 实现的。因此其天生地可以响应中断。

> 问题：同步器是如何响应中断的呢？
>
> 在 acquireInterruptibly 当中的每个循环来检验是否 interrupted，如果是，则抛出异常。

除此之外，acquireNanos 还实现了针对超时获取（提前唤醒）的特性。为了防止提前通知，计算 nanosTimeout -= now - lastTime，now 和 lastTime 为当前唤醒时间和上次唤醒时间。

如果 nanosTimeout 仍然大于0，说明其实还没超时，会继续沉睡 nanosTimeout 的时间。

总结，acquire的过程如下：

1. tryAcquire
2. 如果失败了，则看 nanosTimeout 到了没，如果到了，说明超时，返回 false。
3. 如果没到，更新 nanosTimeout，继续沉睡，等待下次的唤醒。

这里有一个细节，当 nanosTimeout 剩下 1000ns 时，不会再沉睡等待了，而是直接自旋。这是因为超时等待的时间精度有限，在 nanosTimeout 很短的情况下计算不精确。

释放的过程则与互斥锁的释放是一致的。（毕竟获取到锁之后就是一个普通的互斥锁了）